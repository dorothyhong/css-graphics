(function () {
    const aspectRatio = 0.70; // Define an aspect ratio for the chart
  
    // Get the container and its dimensions
    const container = document.getElementById("line-chart");
    const containerWidth = container.offsetWidth; // Use offsetWidth for full element width
    const containerHeight = containerWidth * aspectRatio; // Calculate the height based on the width and aspect ratio
  
    // Calculate the dynamic margins
    const dynamicMargin = {
      top: containerHeight * 0.05,    // 5% of the container height
      right: containerWidth * 0.1,  // 10% of the container width
      bottom: containerHeight * 0.1, // 10% of the container height
      left: containerWidth * 0.1    // 5% of the container width
    };
  
    // Calculate the width and height for the inner drawing area
    const width = containerWidth - dynamicMargin.left - dynamicMargin.right;
    const height = containerHeight - dynamicMargin.top - dynamicMargin.bottom;
  
    // Append SVG object
    const svg = d3.select("#line-chart").append("svg")
      .attr('viewBox', `0 0 ${containerWidth} ${containerHeight}`)
      .attr('preserveAspectRatio', 'xMinYMin meet')
      .append('g')
      .attr('transform', `translate(${dynamicMargin.left},${dynamicMargin.top})`);
  
    // X and Y scales
    const x = d3.scaleTime().range([0, width]);
    const y = d3.scaleLinear().range([height, 0]);
  
    // Define the axes
    const xAxis = d3.axisBottom(x).tickFormat(d3.timeFormat("%Y"));
    const yAxis = d3
        .axisLeft(y)
        .tickFormat(d => `$ ${d3.format(".2f")(d)}`);
    
    const colorScale = d3.scaleOrdinal()
      .domain(["22 Panel System Residential PV", "200 kW Commercial PV", "100 MW Utility-Scale PV, Fixed Tilt", "100 MW Utility-Scale PV, One Axis Tracker"])
      .range(["#e41a1c", "#377eb8", "#4daf4a", "#984ea3"]);
  
    const tooltip = d3.select("body").append("div").attr("class", "tooltip");
  
    // Load and process the CSV data
  d3.csv("./data/graph-5-data.csv").then((data) => {
    // Parse years and convert string values to numbers
    data.forEach((d) => {
      d.Year = new Date(+d.Year, 0, 1);
      for (let prop in d) {
        if (prop !== "Year") d[prop] = +d[prop];
      }
    });

    // Update the scale domains with the processed data
    x.domain(d3.extent(data, (d) => d.Year));
    const maxYValue = Math.ceil(d3.max(data, (d) => Math.max(d["22 Panel System Residential PV"], d["200 kW Commercial PV"], d["100 MW Utility-Scale PV, Fixed Tilt"], d["100 MW Utility-Scale PV, One Axis Tracker"])));
    y.domain([0, maxYValue]);
    // Draw the Y-axis
    svg.append("g").call(yAxis).attr("class", "chart-labels");

    // Append "in millions" label
    // svg.append("text")
    //   .attr("class", "chart-labels")
    //   .attr("text-anchor", "middle")
    //   .attr("transform", `translate(-${dynamicMargin.left / 2}, ${height / 2}) rotate(-90)`)
    //   .style("fill", "#000")
    //   .text("in millions");

    // Draw the X-axis
    svg.append("g")
      .attr("transform", `translate(0,${height})`)
      .call(xAxis);

    // Define the line generator
    const lineGenerator = d3.line()
      .x((d) => x(d.Year))
      .y((d, i) => y(d[i]));

    // Draw the lines
    const keys = ["22 Panel System Residential PV", "200 kW Commercial PV", "100 MW Utility-Scale PV, Fixed Tilt", "100 MW Utility-Scale PV, One Axis Tracker"];
    keys.forEach(key => {
      svg.append("path")
        .datum(data)
        .attr("fill", "none")
        .attr("stroke", colorScale(key))
        .attr("stroke-width", 1.5)
        .attr("d", d3.line()
          .x(d => x(d.Year))
          .y(d => y(d[key]))
        );
    });


    function onMouseMove(event) {
      const [xPos, yPos] = d3.pointer(event, this);
      const date = x.invert(xPos);
      const hoverData = data.find(d => d.Year.getFullYear() === date.getFullYear());

      // Position tooltip
      tooltip
        .style("top", `${yPos + dynamicMargin.top}px`)
        .style("left", `${xPos + dynamicMargin.left}px`)
        .style("visibility", "visible");

      const formatNumber = d3.format(",");
      if (hoverData) {
        tooltip.html(`
              <div class="tooltip-title">${hoverData.Year.getFullYear()}</div>
              <table class="tooltip-content">
                  <tr>
                      <td><span class="color-legend" style="background-color: ${colorScale("22 Panel System Residential PV")};"></span>22 Panel System Residential PV</td>
                      <td class="value">${formatNumber(hoverData["22 Panel System Residential PV"])}</td>
                  </tr>
                  <tr>
                      <td><span class="color-legend" style="background-color: ${colorScale("200 kW Commercial PV")};"></span>200 kW Commercial PV</td>
                      <td class="value">${formatNumber(hoverData["200 kW Commercial PV"])}</td>
                  </tr>
                  <tr>
                      <td><span class="color-legend" style="background-color: ${colorScale("100 MW Utility-Scale PV, Fixed Tilt")};"></span>100 MW Utility-Scale PV, Fixed Tilt</td>
                      <td class="value">${formatNumber(hoverData["100 MW Utility-Scale PV, Fixed Tilt"])}</td>
                  </tr>
                  <tr>
                      <td><span class="color-legend" style="background-color: ${colorScale("100 MW Utility-Scale PV, One Axis Tracker")};"></span>100 MW Utility-Scale PV, One Axis Tracker</td>
                      <td class="value">${formatNumber(hoverData["100 MW Utility-Scale PV, One Axis Tracker"])}</td>
                  </tr>
              </table>
            `);
      }
    }

    const mouseG = svg.append("g").attr("class", "mouse-over-effects");

    // Append a line that will follow the mouse cursor
    mouseG.append("path")
      .attr("class", "mouse-line")
      .style("stroke", "#999")
      .style("stroke-width", "0.5px")
      .style("opacity", "0");

    // Create a rect for listening to mouse events
    svg.append("rect")
      .attr("class", "listening-rect")
      .attr("width", width)
      .attr("height", height)
      .attr("fill", "none")
      .attr("pointer-events", "all")
      .on("mousemove", onMouseMove)
      .on("mouseout", () => {
        tooltip.style("visibility", "hidden");
        mouseG.selectAll("circle").style("opacity", "0");
        mouseG.select(".mouse-line").style("opacity", "0");
      });
  });
})();